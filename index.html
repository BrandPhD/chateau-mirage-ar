
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Château Mirage 3D AR Bottle</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <style>
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: #000;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      }
      #app {
        position: relative;
        width: 100%;
        height: 100%;
      }
      #video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        transform: scaleX(-1);
        filter: brightness(1.05) contrast(1.05);
      }
      #three-container {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }
      canvas {
        pointer-events: auto;
      }
      #hud {
        position: absolute;
        left: 50%;
        bottom: 14px;
        transform: translateX(-50%);
        padding: 8px 16px;
        border-radius: 999px;
        background: linear-gradient(to right, rgba(10,0,30,0.75), rgba(40,0,70,0.75));
        color: #f7e6c9;
        text-align: center;
        font-size: 13px;
        max-width: calc(100% - 32px);
        text-shadow: 0 2px 6px rgba(0,0,0,0.6);
      }
      #hud b {
        text-transform: uppercase;
        letter-spacing: 0.08em;
        font-size: 11px;
        opacity: 0.9;
      }
      #errorMessage {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #fff;
        text-align: center;
        padding: 16px;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="app">
      <video id="video" autoplay playsinline muted></video>
      <div id="three-container"></div>
      <div id="hud">
        <div><b>Château Mirage</b></div>
        Drag to rotate the bottle · Pinch to zoom
      </div>
      <div id="errorMessage">
        <p>We could not access your camera.</p>
        <p>Please check browser permissions and reload this page.</p>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r152/three.min.js"></script>

    <script>
      // Camera background
      async function startCamera() {
        const video = document.getElementById('video');
        const errorMessage = document.getElementById('errorMessage');

        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            video: { facingMode: { ideal: 'environment' } },
            audio: false
          });
          video.srcObject = stream;
        } catch (err) {
          console.error('Camera error:', err);
          errorMessage.style.display = 'block';
        }
      }

      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        startCamera();
      } else {
        document.getElementById('errorMessage').style.display = 'block';
      }

      const container = document.getElementById('three-container');
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 0, 6);

      const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      container.appendChild(renderer.domElement);

      const ambient = new THREE.AmbientLight(0xffffff, 1.0);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 0.6);
      dir.position.set(2, 5, 4);
      scene.add(dir);

      const bottleGroup = new THREE.Group();
      scene.add(bottleGroup);

      const loader = new THREE.TextureLoader();
      const frontTex = loader.load('bottle_front.png', () => {
        console.log('Front texture loaded');
      }, undefined, (err) => {
        console.error('Error loading front texture', err);
      });
      const backTex = loader.load('bottle_back.png', () => {
        console.log('Back texture loaded');
      }, undefined, (err) => {
        console.error('Error loading back texture', err);
      });

      frontTex.anisotropy = 8;
      backTex.anisotropy = 8;

      const aspect = 3.4; // approximate height/width ratio
      const width = 1.6;
      const height = width * aspect;

      const geom = new THREE.PlaneGeometry(width, height);

      const matFront = new THREE.MeshBasicMaterial({ map: frontTex, transparent: true });
      const matBack = new THREE.MeshBasicMaterial({ map: backTex, transparent: true, side: THREE.BackSide });

      const frontMesh = new THREE.Mesh(geom, matFront);
      const backMesh = new THREE.Mesh(geom, matBack);
      backMesh.rotation.y = Math.PI;

      bottleGroup.add(frontMesh);
      bottleGroup.add(backMesh);

      bottleGroup.position.y = -0.2;

      const clock = new THREE.Clock();
      function animate() {
        requestAnimationFrame(animate);
        const t = clock.getElapsedTime();
        bottleGroup.position.y = -0.2 + Math.sin(t * 1.2) * 0.08;
        renderer.render(scene, camera);
      }
      animate();

      let isPointerDown = false;
      let lastX = 0;
      let currentRotation = 0;
      let baseScale = 1.0;
      let currentScale = 1.0;
      let lastDistance = 0;

      function getDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx*dx + dy*dy);
      }

      const canvas = renderer.domElement;

      canvas.addEventListener('pointerdown', (e) => {
        isPointerDown = true;
        lastX = e.clientX;
      });

      window.addEventListener('pointermove', (e) => {
        if (!isPointerDown) return;
        const deltaX = e.clientX - lastX;
        lastX = e.clientX;
        currentRotation += deltaX * 0.01;
        bottleGroup.rotation.y = currentRotation;
      });

      window.addEventListener('pointerup', () => { isPointerDown = false; });
      window.addEventListener('pointerleave', () => { isPointerDown = false; });

      // Touch pinch zoom only
      canvas.addEventListener('touchstart', (e) => {
        if (e.touches.length === 2) {
          lastDistance = getDistance(e.touches);
          baseScale = currentScale;
        }
      }, { passive: true });

      canvas.addEventListener('touchmove', (e) => {
        if (e.touches.length === 2) {
          const newDist = getDistance(e.touches);
          const factor = newDist / lastDistance;
          currentScale = Math.min(Math.max(0.7, baseScale * factor), 1.8);
          bottleGroup.scale.set(currentScale, currentScale, currentScale);
        }
      }, { passive: true });

      // Resize handling
      window.addEventListener('resize', () => {
        const w = window.innerWidth;
        const h = window.innerHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      });
    </script>
  </body>
</html>
